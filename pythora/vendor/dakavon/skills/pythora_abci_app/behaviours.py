# ------------------------------------------------------------------------------
#
#   Copyright 2023
#   Copyright 2023 valory-xyz
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import time
from abc import ABC
from enum import Enum
import requests
from typing import Any, cast
from pathlib import Path
from aea.skills.behaviours import State, FSMBehaviour
from aea.contracts.base import Contract, contract_registry
from aea.configurations.loader import ComponentType, load_component_configuration
from aea_ledger_ethereum import (
    HexBytes,
    JSONLike,
    EthereumApi,
    SignedTransaction,
    EthereumCrypto,
    try_decorator,
)
from packages.dakavon.contracts.pyth import PUBLIC_ID as PYTH_PUBLIC_ID
from packages.dakavon.contracts.pythoraentropy import (
    PUBLIC_ID as PYTHORA_ENTROPY_PUBLIC_ID,
)
from eth_utils import to_bytes
from secrets import token_bytes

GAS = 500_000
GAS_PREMIUM = 1.1  # 10% gas premium
TX_TIMEOUT = 60  # seconds
PYTH_USD_PRICEFEED_ID = (
    "0x0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff"
)


def load_contract(contract_path: Path) -> Contract:
    """Helper function to load a contract."""
    configuration = load_component_configuration(ComponentType.CONTRACT, contract_path)
    configuration._directory = contract_path  # noqa
    if str(configuration.public_id) not in contract_registry.specs:
        # load contract into sys modules
        Contract.from_config(configuration)
    return contract_registry.make(str(configuration.public_id))


class PythoraabciappEvents(Enum):
    """Events for the fsm."""

    DONE = "DONE"
    TIMEOUT = "TIMEOUT"


class PythoraabciappStates(Enum):
    """States for the fsm."""

    FETCHPRICEDATAROUND = "fetchpricedataround"
    CONSUMEPRICEANDPRINTMESSAGEROUND = "consumepriceandprintmessageround"
    REGISTRATIONROUND = "registrationround"
    RESETANDPAUSEROUND = "resetandpauseround"
    UPDATEPRICEDATAROUND = "updatepricedataround"


def signed_tx_to_dict(signed_transaction: Any) -> dict[str, str | int]:
    """Write SignedTransaction to dict."""
    signed_transaction_dict: dict[str, str | int] = {
        "raw_transaction": cast(str, signed_transaction.rawTransaction.hex()),
        "hash": cast(str, signed_transaction.hash.hex()),
        "r": cast(int, signed_transaction.r),
        "s": cast(int, signed_transaction.s),
        "v": cast(int, signed_transaction.v),
    }
    return signed_transaction_dict


@try_decorator("Unable to send transaction: {}", logger_method="warning")
def try_send_signed_transaction(
    ethereum_api: EthereumApi, tx_signed: JSONLike, **_kwargs: Any
) -> str | None:
    """Try send a raw signed transaction."""
    signed_transaction = SignedTransactionTranslator.from_dict(tx_signed)
    hex_value = ethereum_api.api.eth.send_raw_transaction(  # pylint: disable=no-member
        signed_transaction.rawTransaction
    )
    tx_digest = hex_value.hex()
    if not tx_digest.startswith("0x"):
        tx_digest = "0x" + tx_digest
    return tx_digest


class SignedTransactionTranslator:
    """Translator for SignedTransaction."""

    @staticmethod
    def to_dict(signed_transaction: SignedTransaction) -> dict[str, str | int]:
        """Write SignedTransaction to dict."""
        signed_transaction_dict: dict[str, str | int] = {
            "raw_transaction": cast(str, signed_transaction.rawTransaction.hex()),
            "hash": cast(str, signed_transaction.hash.hex()),
            "r": cast(int, signed_transaction.r),
            "s": cast(int, signed_transaction.s),
            "v": cast(int, signed_transaction.v),
        }
        return signed_transaction_dict

    @staticmethod
    def from_dict(signed_transaction_dict: JSONLike) -> SignedTransaction:
        """Get SignedTransaction from dict."""
        if (
            not isinstance(signed_transaction_dict, dict)
            and len(signed_transaction_dict) == 5
        ):
            msg = f"Invalid for conversion. Found object: {signed_transaction_dict}."
            raise ValueError(  # pragma: nocover
                msg
            )
        # return SignedTransaction(
        #     raw_transaction=HexBytes(
        #         cast(str, signed_transaction_dict["raw_transaction"])
        #     ),
        #     hash=HexBytes(cast(str, signed_transaction_dict["hash"])),
        #     r=cast(int, signed_transaction_dict["r"]),
        #     s=cast(int, signed_transaction_dict["s"]),
        #     v=cast(int, signed_transaction_dict["v"]),
        # )
        return SignedTransaction(
            HexBytes(cast(str, signed_transaction_dict["raw_transaction"])),
            HexBytes(cast(str, signed_transaction_dict["hash"])),
            cast(int, signed_transaction_dict["r"]),
            cast(int, signed_transaction_dict["s"]),
            cast(int, signed_transaction_dict["v"]),
        )


ROOT = Path(__file__).parent.parent.parent.parent


class BaseState(State, ABC):
    """Base class for states."""

    _state: PythoraabciappStates = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False  # Initially, the state is not done
        author = PYTH_PUBLIC_ID.author
        name = PYTH_PUBLIC_ID.name
        contract = load_contract(ROOT / author / "contracts" / name)
        self.pyth_contract = contract
        self.pyth_address = "0xDd24F84d36BF92C65F92307595335bdFab5Bbd21"

        pythoraEntropyAuthor = PYTHORA_ENTROPY_PUBLIC_ID.author
        pythoraEntropyName = PYTHORA_ENTROPY_PUBLIC_ID.name
        pythoraEntropyContract = load_contract(
            ROOT / pythoraEntropyAuthor / "contracts" / pythoraEntropyName
        )
        self.pythora_entropy_contract = pythoraEntropyContract
        self.pythora_entropy_contract_address = (
            "0xb2Fa94AEe40Ad375D1bb65F5442f36DBFc0bD35a"
        )

    def act(self) -> None:
        """Perform the act."""
        self._is_done = True
        self._event = PythoraabciappEvents.DONE

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Current event."""
        return self._event

    @property
    def sepolia_ledger_api(self) -> EthereumApi:
        """Get the Ethereum Sepolia ledger api."""
        return EthereumApi(address="https://sepolia.drpc.org", chain_id=str(11155111))

    @property
    def arbitrum_sepolia_ledger_api(self) -> EthereumApi:
        """Get the Arbitrum Sepolia ledger api."""
        return EthereumApi(
            address="https://sepolia-rollup.arbitrum.io/rpc", chain_id=str(421614)
        )

    @property
    def crypto(self) -> EthereumCrypto:
        """Get EthereumCrypto."""
        return EthereumCrypto(private_key_path="ethereum_private_key.txt")

    def build_transaction(self, func, value: int = 0):
        """Build the transaction."""

        nonce = self.sepolia_ledger_api.api.eth.get_transaction_count(
            self.crypto.address
        )
        return func.build_transaction(
            {
                "from": self.crypto.address,
                "nonce": nonce,
                "gas": GAS,
                "gasPrice": int(
                    self.sepolia_ledger_api.api.eth.gas_price * GAS_PREMIUM
                ),
                "value": value,
            }
        )

    def build_transaction_arbitrum_sepolia(self, func, value: int = 0):
        """Build the transaction for Arbitrum Sepolia."""

        nonce = self.arbitrum_sepolia_ledger_api.api.eth.get_transaction_count(
            self.crypto.address
        )
        return func.build_transaction(
            {
                "from": self.crypto.address,
                "nonce": nonce,
                "gas": GAS,
                "gasPrice": int(
                    self.arbitrum_sepolia_ledger_api.api.eth.gas_price * GAS_PREMIUM
                ),
                "value": value,
            }
        )


class FetchPriceDataRound(BaseState):
    """This class implements the behaviour of the state FetchPriceDataRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = PythoraabciappStates.FETCHPRICEDATAROUND

    def act(self) -> None:
        """Perform the act."""

        priceFeed_pythUsd = "0x0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff"  # PYTH/USD price feed ID
        requestUrl = f"https://hermes.pyth.network/v2/updates/price/latest?ids%5B%5D={priceFeed_pythUsd}&encoding=hex&parsed=false"

        try:
            res = requests.get(requestUrl, timeout=10)
            res_json = res.json()

            # Validate that the expected structure is present
            binary = res_json.get("binary", {})
            data_list = binary.get("data", [])

            if not data_list or not isinstance(data_list, list) or not data_list[0]:
                raise ValueError(
                    "Missing or invalid price update data from Pyth response"
                )

            hex_data = data_list[0]

            # Store in shared state for next step (e.g., to call updatePriceFeeds on-chain)
            self.context.shared_state["price_update_data"] = hex_data
            # print(f"### FetchPriceDataRound: Fetched price update data: {hex_data}")

            self._event = PythoraabciappEvents.DONE
        except (KeyError, ValueError) as err:
            self.context.logger.error("Error fetching price data: %s", err)
            self._event = PythoraabciappEvents.TIMEOUT
        finally:
            self._is_done = True


class ConsumePriceAndPrintMessageRound(BaseState):
    """This class implements the behaviour of the state ConsumePriceAndPrintMessageRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = PythoraabciappStates.CONSUMEPRICEANDPRINTMESSAGEROUND

    def act(self) -> None:
        """Perform the act."""

        # Get from shared state for this step: tx_receipt_status
        tx_receipt_status = self.context.shared_state.get("tx_receipt_status")

        if tx_receipt_status is None:
            self.context.logger.error(
                "No transaction receipt status found in shared state."
            )
            raise ValueError("No transaction receipt status found in shared state.")
        elif tx_receipt_status == 1:
            # Read price fron Pyth contract
            pythUsdPrice = self.pyth_contract.get_price_no_older_than(
                ledger_api=self.sepolia_ledger_api,
                contract_address=self.pyth_address,
                id=PYTH_USD_PRICEFEED_ID,
                age=60,  # 60 seconds
            )
            pythUsdPrice = pythUsdPrice.get("price")
            raw_price, _, exponent, _ = pythUsdPrice

            # Calculate the actual price by shifting decimals
            formatted_price = raw_price * (10**exponent)

            self.context.logger.info(
                "Price consumed from Pyth contract | $PYTH: $%.8f", formatted_price
            )

        self._is_done = True
        self._event = PythoraabciappEvents.DONE


class RegistrationRound(BaseState):
    """This class implements the behaviour of the state RegistrationRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = PythoraabciappStates.REGISTRATIONROUND

    def act(self) -> None:
        """Perform the act."""

        # Create entropy and consume random number

        # 1. Generate userRandomNumber - a 32-byte random seed
        user_random_number = token_bytes(32)  # bytes object
        user_random_number_hex = "0x" + user_random_number.hex()

        # print(f"Requesting random number with user seed: {user_random_number.hex()}")
        self.context.logger.info(
            "Requesting random number with user seed: %s", user_random_number.hex()
        )

        # 2. Request a random number from the Pythora Entropy contract
        w3_function = self.pythora_entropy_contract.request_random_number(
            ledger_api=self.arbitrum_sepolia_ledger_api,
            contract_address=self.pythora_entropy_contract_address,
            user_random_number=to_bytes(hexstr=user_random_number.hex()),
        )
        fee_amount = 372357000000001  # got value over etherscan
        raw_tx = self.build_transaction_arbitrum_sepolia(w3_function, value=fee_amount)
        signed_tx = self.crypto.entity.sign_transaction(raw_tx)
        signed_tx_dict = signed_tx_to_dict(signed_tx)

        # 3. Send the signed transaction to the Arbitrum Sepolia network
        tx_hash = try_send_signed_transaction(
            self.arbitrum_sepolia_ledger_api, signed_tx_dict
        )
        self.context.logger.info(f"Transaction hash: {tx_hash}")

        # 4. Wait for the transaction receipt
        tx_receipt = (
            self.arbitrum_sepolia_ledger_api.api.eth.wait_for_transaction_receipt(
                tx_hash, timeout=TX_TIMEOUT
            )
        )
        print(f"Transaction receipt: {tx_receipt}")

        if tx_receipt.status == 1:
            self.context.logger.info(
                "Transaction successful! Random number requested from Pythora Entropy contract."
            )
            sequence_number = (
                self.pythora_entropy_contract.sequence_numbers_by_user_random_number(
                    ledger_api=self.arbitrum_sepolia_ledger_api,
                    contract_address=self.pythora_entropy_contract_address,
                    var_0=user_random_number_hex,
                )
            )
            self.context.logger.info(
                "Sequence number for user random number %s: %s",
                user_random_number_hex,
                sequence_number,
            )
        else:
            self.context.logger.error(
                "Transaction failed! Random number not requested from Pythora Entropy contract."
            )
            raise ValueError("Transaction failed.")

        time.sleep(15)  # Wait for the random number to be generated

        # 5. Fetch the random number from the Pythora Entropy contract and print it
        random_number = self.pythora_entropy_contract.random_numbers_by_sequence_number(
            ledger_api=self.arbitrum_sepolia_ledger_api,
            contract_address=self.pythora_entropy_contract_address,
            var_0=sequence_number["int"],
        )

        raw_random_bytes = random_number["str"]
        random_number_hex = "0x" + raw_random_bytes.hex()

        self.context.logger.info(
            "Random number consumed from Pythora Entropy contract (hex): %s", random_number_hex
        )

        breakpoint()

        self._is_done = True
        self._event = PythoraabciappEvents.DONE


class ResetAndPauseRound(BaseState):
    """This class implements the behaviour of the state ResetAndPauseRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = PythoraabciappStates.RESETANDPAUSEROUND

    def act(self) -> None:
        """Perform the act."""

        self._is_done = True
        self._event = PythoraabciappEvents.DONE
        time.sleep(
            30
        )  # Pause for 30 seconds before next round (we do not want to spend so much gas for now)


class UpdatePriceDataRound(BaseState):
    """This class implements the behaviour of the state UpdatePriceDataRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = PythoraabciappStates.UPDATEPRICEDATAROUND

    def act(self) -> None:
        """Perform the act."""
        print("### UpdatePriceDataRound: Updating price data on-chain...")

        # Get the hex-encoded price update data from the previous round
        price_update_data = self.context.shared_state.get("price_update_data")
        # print(f"### UpdatePriceDataRound: Fetched price update data: {price_update_data}")

        if price_update_data is None:
            raise ValueError("No price update data found in shared state.")
        else:
            # Get the update fee for the price update data
            update_fee = self.pyth_contract.get_update_fee(
                ledger_api=self.sepolia_ledger_api,
                contract_address=self.pyth_address,
                update_data=["0x" + price_update_data],
            )
            update_fee = update_fee.get("feeAmount")
            print(f"### UpdatePriceDataRound: Update fees: {update_fee} Wei")

            try:
                # Create a signed transaction to update the price feeds
                w3_function = self.pythUpdatePriceFeeds(data=price_update_data)
                raw_tx = self.build_transaction(w3_function, value=update_fee)
                signed_tx = self.crypto.entity.sign_transaction(raw_tx)
                signed_tx_dict = signed_tx_to_dict(signed_tx)

                # print(f"### UpdatePriceDataRound: Signed transaction: {signed_tx_dict['raw_transaction']}")
                # self.context.logger.info({signed_tx})
                # print(dir(signed_tx))
                # print(dir(signed_tx_dict))
                # breakpoint()

                # Execute the transaction to update price data
                tx_hash = try_send_signed_transaction(
                    self.sepolia_ledger_api, signed_tx_dict
                )
                self.context.logger.info(f"Transaction hash: {tx_hash}")

                tx_receipt = (
                    self.sepolia_ledger_api.api.eth.wait_for_transaction_receipt(
                        tx_hash, timeout=TX_TIMEOUT
                    )
                )
                print(f"Transaction receipt: {tx_receipt}")
                if tx_receipt.status == 1:
                    self.context.logger.info(
                        "Transaction successful! Price feeds updated on-chain."
                    )
                    self.context.shared_state["tx_receipt_status"] = tx_receipt.status
                elif tx_receipt.status == 0:
                    self.context.logger.error(
                        "Transaction failed! Price feeds not updated on-chain."
                    )
                    self.context.shared_state["tx_receipt_status"] = tx_receipt.status
                else:
                    raise ValueError("Transaction failed.")
            except Exception as e:
                self.context.logger.error("Error updating price feeds: %s", e)

        self._is_done = True
        self._event = PythoraabciappEvents.DONE

    def pythUpdatePriceFeeds(self, data: str):
        """Call "updatePriceFeeds" on Pyth contract"""

        return self.pyth_contract.update_price_feeds(
            ledger_api=self.sepolia_ledger_api,
            contract_address=self.pyth_address,
            update_data=["0x" + data],
        )


class PythoraabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state(
            PythoraabciappStates.REGISTRATIONROUND.value,
            RegistrationRound(**kwargs),
            True,
        )

        self.register_state(
            PythoraabciappStates.FETCHPRICEDATAROUND.value,
            FetchPriceDataRound(**kwargs),
        )
        self.register_state(
            PythoraabciappStates.CONSUMEPRICEANDPRINTMESSAGEROUND.value,
            ConsumePriceAndPrintMessageRound(**kwargs),
        )
        self.register_state(
            PythoraabciappStates.RESETANDPAUSEROUND.value, ResetAndPauseRound(**kwargs)
        )
        self.register_state(
            PythoraabciappStates.UPDATEPRICEDATAROUND.value,
            UpdatePriceDataRound(**kwargs),
        )

        self.register_transition(
            source=PythoraabciappStates.CONSUMEPRICEANDPRINTMESSAGEROUND.value,
            event=PythoraabciappEvents.DONE,
            destination=PythoraabciappStates.RESETANDPAUSEROUND.value,
        )
        self.register_transition(
            source=PythoraabciappStates.FETCHPRICEDATAROUND.value,
            event=PythoraabciappEvents.DONE,
            destination=PythoraabciappStates.UPDATEPRICEDATAROUND.value,
        )
        self.register_transition(
            source=PythoraabciappStates.FETCHPRICEDATAROUND.value,
            event=PythoraabciappEvents.TIMEOUT,
            destination=PythoraabciappStates.REGISTRATIONROUND.value,
        )
        self.register_transition(
            source=PythoraabciappStates.REGISTRATIONROUND.value,
            event=PythoraabciappEvents.DONE,
            destination=PythoraabciappStates.FETCHPRICEDATAROUND.value,
        )
        self.register_transition(
            source=PythoraabciappStates.RESETANDPAUSEROUND.value,
            event=PythoraabciappEvents.DONE,
            destination=PythoraabciappStates.REGISTRATIONROUND.value,
        )
        self.register_transition(
            source=PythoraabciappStates.UPDATEPRICEDATAROUND.value,
            event=PythoraabciappEvents.DONE,
            destination=PythoraabciappStates.CONSUMEPRICEANDPRINTMESSAGEROUND.value,
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Pythoraabciapp FSM behaviour.")

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Pythoraabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the act."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
        self.context.logger.info(f"Entering {self.current}")
        super().act()

    def terminate(self) -> None:
        """Implement the termination."""
        os._exit(0)
